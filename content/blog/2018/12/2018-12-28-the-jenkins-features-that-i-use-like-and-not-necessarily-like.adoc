---
layout: post
title: "The Jenkins features that I use, like, and not necessarily like"
tags:
- jenkins
- devopsworldjenkinsworld2018
author: vspendyala
---

NOTE: This is a guest blog post by Vishnu Pendyala from link:https://www.cisco.com/[Cisco].


 We use Jenkins predominantly at Cisco and particularly to build Wireless products that I lead the DevOps for. The wireless products for which we build images are Access Points (AP), Wireless LAN Controllers (WLC), and a product called Mobility Express (ME) that is a lightweight hybrid of the two. The images that we build work like Operating Systems for the respective hardware. 
 
 Builds for these images happen in two stages. In the first stage, the build generates the AP images, which are in the form of tar files. These tar files bundle into the WLC and ME images built in the second stage. The process is shown in the figure below. The source code for these images goes through a number of pre-commit checks in the Continuous Integration process before getting merged.

image::/images/post-images/2019-01-09/diagram.png[role="center",width=800]
      

== In the above process, the following features of Jenkins or its plugins, in no particular order come-in extremely handy.

* Upstream / Downstream jobs to implement the sequencing of the builds.
* Organizing the 100s of jobs we have for the various active releases and branches we support at any time, into views and folders.
* Using labels and multi-configuration project configurations to do the builds for a number of flavors of AP, WLC, and ME.
* The silent build feature of Gerrit plugin is useful for experimental builds on their way to become mandatory and also for builds whose return value is non-consequential, in which case the status is sent back in a different way.
* Log parsing feature is of immense help when the console logs are humongous and also when we want the build to fail based on some error patterns in the logs.

== Every tool comes with its own scope for improvement and hereâ€™s where I feel Jenkins needs some help:

* Configuration is a one-way lane sometimes. It is not easy or possible to reconfigure. For instance, a freestyle project cannot be converted into a multi-configuration project later, when we want to add newer, but similar builds.
* Need for plugins even for basic functionality, quite a bit of which can be made default in Jenkins.
* Plugin security is a concern. There does not seem to be any certification process for the plug-ins, yet. There is a risk of using rogue plugins or carelessly written plugins to ruin the workflow.
* Inefficient constructs in plugins go unchecked and can entice a novice to use them. For instance, plugins which provide busy polling the SCM system can cause substantial load.
* Currently, Jenkins upgrade is non-trivial and can take days.
* Some of the functionality is unreliable. For instance, CI builds sometimes do not start automatically.
* Clumsy handling of humongous console logs. Browsers struggle to load the Full Console log. Need better ways of showing the logs.
* On a minor note, the Execute Shell box does not have wrap-around, making it a challenge when using the trackpad on laptops.

== Jenkins is still the best.

*  Intuitive usage. In the decade-long use of Jenkins, I hardly had to refer to any documentation. The GUI is quite self-guiding.
*  Plenty of Plugins (and functionality) to choose from.
* Simple concept of scheduling expanded beyond all recognition! A great example of tool innovation.
* Quite scalable, appropriate evolution to meet the growing needs of DevOps.
* Meets requirements for most CI / CD environments.

I also spoke about this at DevOps World - Jenkins World 2018.
Here is the link to the presentation I gave at the conference: https://sched.co/FCei

