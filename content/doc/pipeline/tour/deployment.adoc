---
layout: documentation
title: Deployment
---
:toc:

As your pipeline grows to accomodate deployment, you will have multiple stages.
You have likely already seen stages in use in some examples:

== Multiple stages

Adding more stages makes it clear what you pipeline is doing.

[pipeline]
----
// Declarative //
pipeline {
     agent docker:'node'
     stages {
         stage('build') {
             sh 'echo building...'
         }
         stage('test') {
             sh 'echo testing...'
         }
         stage('deploy') {
             retry(3) {
                sh 'echo deploying...'
             }
         }
     }
}
----

This is a pipeline of build->test->deploy. The `deploy` stage, actually retries
a script 3 times.

Retrying things, with a timeout, is a pretty common pattern in deployment:

[source,groovy]
----
timeout(time: 3, unit: 'MINUTES') {
   retry(5) {
       sh 'echo deploying'
   }
}
----

This gives it 5 chances to get it right, but in 3 minutes (if your app isn't
deployed in 3 minutes, it's free!).

You can also sleep between steps:

[source,groovy]
----
    stage('deploy') {
        sh 'echo deploying...'
        sleep 30
        sh 'echo 30 seconds should be long enough'
    }
----
Default is in seconds.

== Stages as deploy environments

One useful way to use stages is to have them represent deployment environments:

[pipeline]
----
// Declarative //
pipeline {
     agent label:''
     stages {
         stage('Build') {
             sh 'echo building...'
         }
         stage('Test') {
             sh 'echo testing...'
         }
         stage('Deploy - Staging') {
             sh 'echo deploying to staging...'
             sh 'echo smoke tests...'
         }
         stage('Deploy - Production') {
             sh 'echo deploying to production...'
         }
     }
}
----

The final 2 stages represent staging and production environments. Typically you
would want to run some smoke tests before things are promoted to the production
environment.

== Asking for human input to proceed

Often when passing between stages, especially environment stages, you may want
a human to judge if the application is in a good enough state to promote (you
can also ask for input parameters too, but I won't show that here):

[pipeline]
----
// Declarative //
pipeline {
     agent none
     stages {

         stage('Deploy - Staging') {
             node('master') {
                checkout scm
                sh 'echo deploying $APP_NAME to staging...'
             }
         }

         stage('Sanity check') {
             input "Does the staging environment for ${env.APP_NAME} look ok?"
         }

         stage('Deploy - Production') {
             node('master') {
                 sh 'echo deploying $APP_NAME to production'
             }
         }
     }

     environment {
        APP_NAME = 'my-app'
     }
}
----

In this example, the "Sanity check" stage actually blocks for input and won't
proceed without a person allowing it to. You may want to do this as you don't
trust your test suite, but don't tell anyone that, it can be our secret.

There are also a few other things going on in the human input example above:
ie. `agent none` means that is is up to each stage to get its own `node` to run
steps on. This also means that when it is waiting for input from a person, it
isn't keeping an agent running (ie it can wait for hours or days, with no harm
done).


== Conclusion
