---
layout: section
title: Extending with Shared Libraries
---
:notitle:
:description:
:author:
:email: jenkinsci-docs@googlegroups.com
:sectanchors:
:imagesdir: /doc/book/resources
:hide-uri-scheme:
:toc:

= Extending with Shared Libraries

As Pipeline is adopted for more and more projects in an organization, common
patterns are likely to emerge. Oftentimes it is useful to share parts of
Pipelines between various projects to reduce redundancies and keep code
"DRY"
footnoteref:[dry, http://en.wikipedia.org/wiki/Don\'t_repeat_yourself].

Pipeline has support for creating "Shared Libraries" which can be defined in
external source control repositories and loaded into existing Pipelines.

== Defining Shared Libraries

An Shared Library is defined with a name, a source code retrieval method such
as by SCM, and optionally a default version.  The name should be a short
identifier as it will be used in scripts.

The version could be anything understood by that SCM; for example, branches,
tags, and commit hashes all work for Git.  You may also declare whether scripts
need to explicitly request that library (detailed below), or if it is present
by default.  Furthermore, if you specify a version in Jenkins configuration,
you can block scripts from selecting a _different_ version.

The best way to specify the SCM is using an SCM plugin which has been
specifically updated to support a new API for checking out an arbitrary named
version (_Modern SCM_ option).  As of this writing, the latest versions of the
Git and Subversion plugins support this mode; others should follow.

If your SCM plugin has not been integrated, you may select _Legacy SCM_ and
pick anything offered.  In this case, you need to include
`${library.yourLibName.version}` somewhere in the configuration of the SCM, so
that during checkout the plugin will expand this variable to select the desired
version.  For example, for Subversion, you can set the _Repository URL_ to
`https://svnserver/project/${library.yourLibName.version}` and then use
versions such as `trunk` or `branches/dev` or `tags/1.0`.

=== Directory structure

The directory structure of a Shared Library repository is as follows:

[source]
----
(root)
+- src                     # Groovy source files
|   +- org
|       +- foo
|           +- Bar.groovy  # for org.foo.Bar class
+- vars
|   +- foo.groovy          # for global or custom step 'foo' variable
|   +- foo.txt             # help for 'foo'
+- resources               # resource files (external libraries only)
|   +- org
|       +- foo
|           +- bar.json    # static helper data for org.foo.Bar
----

The `src` directory should look like standard Java source directory structure.
This directory is added to the classpath when executing Pipelines.

The `vars` directory hosts scripts that define global variables accessible from
Pipeline.
The basename of each `*.groovy` file should be a Groovy (~ Java) identifier, conventionally `camelCased`.
The matching `*.txt`, if present, can contain documentation, processed through the system’s configured markup formatter
(so may really be HTML, Markdown, etc., though the `txt` extension is required).

The Groovy source files in these directories get the same “CPS transformation”
as in Scripted Pipeline.

A `resources` directory allows the `libraryResource` step to be used from an
external library to load associated non-Groovy files.
Currently this feature is not supported for internal libraries.

Other directories under the root are reserved for future enhancements.

=== Global Shared Libraries

There are several places where Shared Libraries can be defined, depending on
the use-case. _Manage Jenkins » Configure System » Global Pipeline Libraries_
as many libraries as necessary can be configured.

image::pipeline/add-global-pipeline-libraries.png["Add a Global Pipeline Library", role=center]

Since these libraries will be globally usable, any Pipeline in the system can
utilize functionality implemented in these libraries.

These libraries are considered "trusted:" they can run any methods in Java,
Groovy, Jenkins internal APIs, Jenkins plugins, or third-party libraries.  This
allows you to define libraries which encapsulate individually unsafe APIs in a
higher-level wrapper safe for use from any Pipeline.  Beware that **anyone able to
push commits to this SCM repository could obtain unlimited access to Jenkins**.
You need the _Overall/RunScripts_ permission to configure these libraries
(normally this will be granted to Jenkins administrators).

=== Folder-level Shared Libraries

Any Folder created can have Shared Libraries associated with it. This mechanism
allows scoping of specific libraries to all the Pipelines inside of the folder
or subfolder.

Folder-based libraries are not considered "trusted:" they run in the Groovy
sandbox just like typical Pipelines.

===  Automatic Shared Libraries

Other plugins may add ways of defining libraries on the fly.
For example, the
link:https://plugins.jenkins.io/github-organization-folder[GitHub Organization Folder]
plugin allows a script to use an untrusted library such as
`github.com/someorg/somerepo` without any additional configuration.  In this
case, the specified GitHub repository would be loaded, from the `master`
branch, using an anonymous checkout.

== Using libraries

Shared Libraries marked _Load implicitly_ allows Pipelines to immediately use
classes or global variables defined by any such libraries. To access other
shared libraries, the `Jenkinsfile` needs to use the `@Library`
link:http://groovy-lang.org/objectorientation.html#_annotation[annotation],
specifying the library's name:

image::pipeline/configure-global-pipeline-library.png["Configuring a Global Pipeline Library", role=center]

[source,groovy]
----
@Library('my-shared-library') _
/* Using a version specifier, such as branch, tag, etc */
@Library('my-shared-library@1.0') _
/* Accessing multiple libraries with one statement */
@Library(['my-shared-library', 'otherlib@abc1234']) _
----

The annotation can be placed anywhere in the script where an annotation is permitted
by Groovy.  When referring to classes inside libraries (in `src/` directories),
conventionally the annotation goes on an `import` statement:

[source,groovy]
----
@Library('somelib')
import com.mycorp.pipeline.somelib.UsefulClass
----

[TIP]
====
For Shared Libraries which only define Global Variables (`vars/`), or a
`Jenkinsfile` which only uses the Global Variables of a library, the
link:http://groovy-lang.org/objectorientation.html#_annotation[annotation]
pattern `@Library('my-shared-library') _` may be useful for keeping code
concise. In essence, instead of annotating an unnecessary `import` statement,
the symbol `_` is annotated.

Do not `import` Global Variables (they are loaded automatically).
Doing so can cause the Groovy compiler to produce confusing error messages.
====

Libraries are resolved and loaded during _compilation_ of the Pipeline script,
before it starts executing.  This allows the Groovy compiler to understand the
meaning of symbols used in static type checking, and permits them to be used
in type declarations in the script, for example:

[source,groovy]
----
@Library('somelib')
import com.mycorp.pipeline.somelib.Helper

int useSomeLib(Helper helper) {
    helper.prepare()
    return helper.count()
}

echo useSomeLib(new Helper('some text'))
----

Global Variables and custom steps, on the other hand, are resolved at runtime.

=== Library versions

The "Default version" for a configured Shared Library is used when "Load
implicitly" is checked, or if a Pipeline references the library only by name,
for example `@Library('my-shared-library') _`. If a "Default version" is *not*
defined, the Pipeline must specify a version, for example
`@Library('my-shared-library@master') _`.

If "Allow default version to be overridden" is enabled in the Shared Library's
configuration, a `@Library` annotation may also override a default version
defined for the library. This also allows a library with "Load implicitly" to
be loaded from a different version if necessary.

=== Retrieval Method

The best way to specify the SCM is using an SCM plugin which has been
specifically updated to support a new API for checking out an arbitrary named
version (**Modern SCM** option). As of this writing, the latest versions of the
Git and Subversion plugins support this mode.

image::pipeline/global-pipeline-library-modern-scm.png["Configuring a 'Modern SCM' for a Pipeline Library", role=center]

==== Legacy SCM

SCM plugins which have not yet been updated to support the newer features
required by Shared Libraries, may still be used via the **Legacy SCM** option.
In this case, include `${library.yourlibrarynamehere.version}` wherever a
branch/tag/ref may be configured for that particular SCM plugin.  This ensures
that during checkout of the library's source code, the SCM plugin will expand
this variable to checkout the appropriate version of the library.

image::pipeline/global-pipeline-library-legacy-scm.png["Configuring a 'Legacy SCM' for a Pipeline Library", role=center]

=== Pretesting library changes

If you notice a mistake in a build using an untrusted library,
simply click the _Replay_ link to try editing one or more of its source files,
and see if the resulting build behaves as expected.
Once you are satisfied with the result, follow the diff link from the build’s status page,
and apply the diff to the library repository and commit.

(Even if the version requested for the library was a branch, rather than a fixed version like a tag,
replayed builds will use the exact same revision as the original build:
library sources will not be checked out again.)

_Replay_ is not currently supported for trusted libraries.
Modifying resource files is also not currently supported during _Replay_.

== Writing and using library contents

Now let's look at how to add items to Shared Libraries and how to use those items.

=== Resources
Shared libraries can contain general resource files, such as properties files.
To add resources, simply add files to the `resources/` directory tree.
External libraries may then load these files using the `libraryResource` step,
which accepts a relative pathname, akin to Java resource loading:

[source,groovy]
----
def request = libraryResource 'com/mycorp/pipeline/somelib/request.json'
----

The file is loaded as a string, suitable for passing to APIs or saving
to a workspace using `writeFile`.

Avoid adding resources directly under the `resources/` directory.
Multiple libraries maybe be loaded by one pipeline, but resources are referenced using
only a relative path.
Use a deeper, unique directory structure to avoid resource name conflicts with other libraries.

=== Global variables

If a file in the `vars` directory contains one or more methods (other than `call`),
a global variable of that name is created, and the methods are added to that global.
This is a convenient way to create a group of related methods in a
single `.groovy` file and access as members of an object.

For example:

.var/log.groovy
[source,groovy]
----
def info(message) {
    echo "INFO: ${message}"
}

def warning(message) {
    echo "WARNING: ${message}"
}
----

.Jenkinsfile
[source,groovy]
----
@Library('utils') _

log.info 'Starting'
log.warning 'Nothing to do!'
----

Declarative Pipeline does not allow usage of this kind of global variable
outside of a `script` directive
(link:https://issues.jenkins-ci.org/browse/JENKINS-42360[JENKINS-42360]).

.Jenkinsfile
[source,groovy]
----
@Library('utils') _

pipeline {
    agent none
    stage ('Example') {
        steps {
             script { // <1>
                 log.info 'Starting'
                 log.warning 'Nothing to do!'
             }
        }
    }
}
----
<1> `script` directive required to access global variables in Declarative Pipeline.

[NOTE]
====
A global variable defined in a shared library will only show up in _Global Variables
Reference_ (under _Pipeline Syntax_) after Jenkins loads and uses that library
as part of a successful Pipeline run.
====

.Avoid preserving state in global variables
[WARNING]
====
Avoid defining global variables with methods that interact or preserve state.
Use a static class or instantiate a local variable of a class instead.

The example below shows a global variable `customer` which stores a `name` value.
It also outputs a message when name is set.

.var/customer.groovy
[source,groovy]
----
def setName(value) {
    privateName = value
    echo "Setting name to ${privateName}"
}
def getName() {
    privateName
}
----

====

=== Custom steps

Custom steps are a special form of Global Variable,
which create a method with the same name as their containing file
(instead of an object with one or more methods attached).  They behave similar to
built-in steps, such as `sh` or `git`, and can also call built-in steps, other
other custom steps, or other valid Pipeline
link:http://groovy-lang.org/syntax.html[Groovy code].

To define a custom step create a file in the `vars` directory containing only a `call` method.

For example, the file below would create a custom step named `sayHello`:

.vars/sayHello.groovy
[source,groovy]
----
def call(String name = 'human') {
    // Any valid Scripted Pipeline and steps can be used here
    echo "Hello, ${name}."
    echo "I'm Jenkins!"
}
----

The Pipeline would then be able to call this step:

.Jenkinsfile
[source,groovy]
----
@Library('utils') _

sayHello 'Joe'
sayHello() /* invoke with default arguments */
----

==== Extending the DSL

Custom steps can also take curly-brace blocks (known in Groovy as
link:http://groovy-lang.org/closures.html[`Closures`]),
just like built-in steps. The Closure can then be executed as part of the
custom step.
When this isDefine explicitly to clarify the intent of the step, for
example:

.vars/windows.groovy
[source,groovy]
----
def call(Closure body) {
    node('windows') {
        body()
    }
}
----

The Pipeline can then use this variable like any built-in step which
accepts a block:

.Jenkinsfile
[source,groovy]
----
windows {
    bat "cmd /?"
}
----

==== Defining a more structured DSL

If you have a lot of Pipelines that are mostly similar, the global
variable mechanism provides a handy tool to build a higher-level DSL
that captures the similarity. For example, all Jenkins plugins are built and
tested in the same way, so we might write a step named
`buildPlugin`:

.vars/buildPlugin.groovy
[source,groovy]
----
def call(body) {
    // evaluate the body block, and collect configuration into the object
    def config = [:]
    body.resolveStrategy = Closure.DELEGATE_FIRST
    body.delegate = config
    body()

    // now build, based on the configuration provided
    node {
        git url: "https://github.com/jenkinsci/${config.name}-plugin.git"
        sh "mvn install"
        mail to: "...", subject: "${config.name} plugin build", body: "..."
    }
}
----

Assuming the script has either been loaded as a
<<global-shared-libraries,Global Shared Library>> or as a
<<folder-level-shared-libraries, Folder-level Shared Library>>
the resulting `Jenkinsfile` will be dramatically simpler:

[pipeline]
----
// Script //
buildPlugin {
    name = 'git'
}
// Declarative not yet implemented //
----

=== Groovy classes

Shared libraries can also hold normal
link:http://groovy-lang.org/syntax.html[Groovy code] stored under the `src` directory.
The `src` directory behaves exactly like any regular groovy source tree -
files are laid out in directories matching their package name and contain
classes matching their file names:

.src/org/acme/Calculator.groovy
[source,groovy]
----
package org.acme;

class Calculator {
  def add(int a, int b) {
    a + b
  }
}
----

.Jenkinsfile
[source, groovy]
----
@Library('acme') import org.acme.Calculator
def calc = new Calculator()
echo calc.add(2, 3)
----

We can also use `import static` to allow us to call static methods from a class
without specifying the class.  Use this with caution as classes may have method
names that conflict.

.src/org/acme/Calculator.groovy
[source,groovy]
----
package org.acme;

class Calculator {
  static def add(int a, int b) {
    a + b
  }
}
----

.Jenkinsfile
[source, groovy]
----
@Library('acme') import static org.acme.Calculator.*

echo add(2, 3)
----

==== Saving state

Any class used in Pipeline that saves state inside it
*must* implement the `Serializable` interface.
Without this interface, instances of the class will not be able to
properly suspend and resume in Jenkins.


.src/org/acme/Point.groovy
[source,groovy]
----
package org.acme;

// point in 3D space
class Point implements Serializable {
  float x,y,z; // <1>
}
----
<1> Fields save state, so this class must implement `Serializable`.

==== Accessing steps

Unlike Global Variables (and custom steps),
Library classes cannot directly call Pipeline steps such as `sh` or `git`.

The best way to allow Groovy classes to access Pipeline steps is to explicitly
pass the Pipeline script object to the library class as part of the constructor.
If the library needs to access global variables, such as `env`,
those can be accessed via the explicitly passed scrip object as well.

Here's an example of passing the script as part of the constructor:

.src/org/acme/Utilities.groovy
[source,groovy]
----
package org.acme
class Utilities implements Serializable { // <1>
  Script script
  Utilities(Script pipeline) {this.script = script}
  def mvn(args) {
    script.sh "${script.tool 'Maven'}/bin/mvn -o ${args}"
  }
}
----
<1> This class saves state, so it *must* implement the `Serializable` interface.

.Jenkinsfile
[source,groovy]
----
@Library('utils') import org.acme.Utilities
def utils = new Utilities(this)
node {
  utils.mvn 'clean package'
}
----

Here's an example showing the script being passed directly to a `static` method:

.src/org/acme/Utilities.groovy
[source,groovy]
----
package org.foo
class Utilities {
  static def mvn(script, args) {
    script.sh "${script.tool 'Maven'}/bin/mvn -s ${script.env.HOME}/jenkins.xml -o ${args}"
  }
}
----

.Jenkinsfile
[source,groovy]
----
@Library('utils') import static org.foo.Utilities.*
node {
  mvn this, 'clean package' // <1>
}
----
<1> `mvn` method called directy due to `import static`.

.Bare methods (not recommended)
[NOTE]
====

Groovy classes can also use a process similar to Global Variables,
defining methods outside of the scope of a `class` to gain access Pipeline steps.
For example:

.src/org/acme/Zot.groovy
[source,groovy]
----
package org.acme;

def Zing(name) {
  echo "Zing: ${name}"
}
----

Which can then be called from a Scripted Pipeline:

.Jenkinsfile
[source,groovy]
----
def z = new org.acme.Zot()
z.Zing(name)
----

This approach has limitations, such as not being able to use inheritance,
and the behavior is not very well defined.
====

==== Using third-party libraries

It is possible to use third-party Java libraries, typically found in
link:http://search.maven.org/[Maven Central],
from *trusted* library code using the `@Grab` annotation.  Refer to the
link:http://docs.groovy-lang.org/latest/html/documentation/grape.html#_quick_start[Grape documentation]
for details, but simply put:

[source,groovy]
----
@Grab('org.apache.commons:commons-math3:3.4.1')
import org.apache.commons.math3.primes.Primes
void parallelize(int count) {
  if (!Primes.isPrime(count)) {
    error "${count} was not prime"
  }
  // ...
}
----

Third-party libraries are cached by default in `~/.groovy/grapes/` on the
Jenkins master.
