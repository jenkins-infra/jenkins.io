---
layout: section
---
ifdef::backend-html5[]
:notitle:
:description:
:author:
:email: jenkinsci-docs@googlegroups.com
:sectanchors:
:toc:
:hide-uri-scheme:
endif::[]

= Managing Nodes

== Launch inbound agent via Windows Scheduler

If you are having trouble getting the inbound agent installed as a Windows service (i.e., you followed https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins+as+a+Windows+service[the instructions on installing the agent as a service here] but it didn't work), an alternative method of starting the service automatically when Windows starts is to use the Windows Scheduler. 

We take advantage of the Windows Scheduler's ability to run command at system startup

. Configure your node to use the "Launch agents by connecting it to the master" launch method
* Click Save
. Note the command required to launch the agent
* On the new agent node's Jenkins page, note the agent command line shown. 
** It will be like: java -jar agent.jar -jnlpUrl http://<JenkinsHostName>:8080/computer/<nodeName>/slave-agent.jnlp -secret <some_long_hex_string>
. Obtain the agent.jar file and copy it to your new Windows agent node
* In the command line noted in the last step, the "agent.jar" is a hyperlink. Click it to download the agent.jar file.
* Copy the agent.jar file to a permanent location on your agent machine
. Ensure that you have a java version available on your agent machine
* If not, obtain and install a link:/doc/administration/requirements/java/[supported version] of Java
. Run the command manually from a CMD window on your agent to confirm that it works
* Open the CMD window
* Run the command (the one like java -jar agent.jar -jnlpUrl http://<JenkinsHostName>:8080/computer/<nodeName>/slave-agent.jnlp -secret <some_long_hex_string>)
* Go back to the node's web page in Jenkins.  If everything works then page should say "Agent is connected"
* Stop the command (control-c)
. Register a new scheduled job to run the same command
* Open "Task Scheduler" on your windows machine
** Start -> Run: task Scheduler
* Create a basic task (Menu: Action -> Create Basic Task)
** First page of the wizard:
*** Name: Jenkins Agent
*** Description (optional)
*** Click Next
** Next page of the wizard
*** When do you want the task to start: select "When the computer starts"
*** Click Next
** Next page of the wizard
*** What action do you want the task to perform: select "Start a program"
*** Click Next
** Next page of the wizard
*** Program/Script: enter "java.exe" (or the full path to your java.exe)
*** Add arguments: enter the rest of the command, like " -jar agent.jar -jnlpUrl http://<JenkinsHostName>:8080/computer/<nodeName>/slave-agent.jnlp -secret <some_long_hex_string>"
*** eg: -jar D:\Scripts\jenkins\agent.jar -jnlpUrl [.nolink]#http://jenkinshost.example.com:8080/computer/buildNode1/slave-agent.jnlp# -secret d6a84df1fc4f45ddc9c6ab34b08f13391983ffffffffffb3488b7d5ac77fbc7
*** Click Next
** Next page of the wizard
*** Click the check box "Open the Properties dialog for this task when I click Finish
*** Click Finish
* Update the task's properties
** On the General tab
*** Select the user to run the task as
*** Select "Run whether user is logged on or not"
** On the settings tab
*** Uncheck "Stop the task if it runs longer than"
*** Check "Run the task as soon as possible after a scheduled start is missed"
*** Check "If the task failed, restart every: 10 minutes", and "Attempt to restart up to: 3 times"
** Click OK
. Start the scheduled task and again check that the agent is connected
* Go back to the node's web page in Jenkins.  If everything works then page should say "Agent is connected"

== Monitor and Restart Offline Agents

This script can monitor and restart offline nodes if they are not disconnected manually.

Of course you can disable email notification. Thanks author for email notification.

This script runs in the Jenkins Script Console or can run periodically as a Jenkins job with the plugin:groovy[Groovy plugin].

Also see link:https://wiki.jenkins-ci.org/display/JENKINS/Display+Information+About+Nodes[Display Information About Nodes]


[source,groovy]
----
import hudson.node_monitors.*
import hudson.slaves.*
import java.util.concurrent.*
 
jenkins = Hudson.instance
 
import javax.mail.internet.*;
import javax.mail.*
import javax.activation.*
 
 
def sendMail (slave, cause) {
   
 message = slave + " slave is down. Check http://JENKINS_HOSTNAME:JENKINS_PORT/computer/" + slave + "\nBecause " + cause
 subject = slave + " slave is offline"
 toAddress = "JENKINS_ADMIN@YOUR_DOMAIN"
 fromAddress = "JENKINS@YOUR_DOMAIN"
 host = "SMTP_SERVER"
 port = "SMTP_PORT"
 
 Properties mprops = new Properties();
 mprops.setProperty("mail.transport.protocol","smtp");
 mprops.setProperty("mail.host",host);
 mprops.setProperty("mail.smtp.port",port);
 
 Session lSession = Session.getDefaultInstance(mprops,null);
 MimeMessage msg = new MimeMessage(lSession);
 
 
 //tokenize out the recipients in case they came in as a list
 StringTokenizer tok = new StringTokenizer(toAddress,";");
 ArrayList emailTos = new ArrayList();
 while(tok.hasMoreElements()) {
   emailTos.add(new InternetAddress(tok.nextElement().toString()));
 }
 InternetAddress[] to = new InternetAddress[emailTos.size()];
 to = (InternetAddress[]) emailTos.toArray(to);
 msg.setRecipients(MimeMessage.RecipientType.TO,to);
 InternetAddress fromAddr = new InternetAddress(fromAddress);
 msg.setFrom(fromAddr);
 msg.setFrom(new InternetAddress(fromAddress));
 msg.setSubject(subject);
 msg.setText(message)
 
 Transport transporter = lSession.getTransport("smtp");
 transporter.connect();
 transporter.send(msg);
}


def getEnviron(computer) {
   def env
   def thread = Thread.start("Getting env from ${computer.name}", { env = computer.environment })
   thread.join(2000)
   if (thread.isAlive()) thread.interrupt()
   env
}

def slaveAccessible(computer) {
    getEnviron(computer)?.get('PATH') != null
}

def numberOfflineNodes = 0
def numberNodes = 0
for (slave in jenkins.slaves) {
   def computer = slave.computer
   numberNodes ++
   println ""
   println "Checking computer ${computer.name}:"
   def isOK = (slaveAccessible(computer) && !computer.offline)
   if (isOK) {
     println "\t\tOK, got PATH back from slave ${computer.name}."
     println('\tcomputer.isOffline: ' + slave.getComputer().isOffline());
     println('\tcomputer.isTemporarilyOffline: ' + slave.getComputer().isTemporarilyOffline());
     println('\tcomputer.getOfflineCause: ' + slave.getComputer().getOfflineCause());
     println('\tcomputer.offline: ' + computer.offline);
     
     
   } else {
     numberOfflineNodes ++
     println "  ERROR: can't get PATH from slave ${computer.name}."
     println('\tcomputer.isOffline: ' + slave.getComputer().isOffline());
     println('\tcomputer.isTemporarilyOffline: ' + slave.getComputer().isTemporarilyOffline());
     println('\tcomputer.getOfflineCause: ' + slave.getComputer().getOfflineCause());
     println('\tcomputer.offline: ' + computer.offline);
     sendMail(computer.name, slave.getComputer().getOfflineCause().toString())
     if (slave.getComputer().isTemporarilyOffline()) {
       if (!slave.getComputer().getOfflineCause().toString().contains("Disconnected by")) {
         computer.setTemporarilyOffline(false, slave.getComputer().getOfflineCause())
       }
     } else {
         computer.connect(true)
     }
   }
 }
println ("Number of Offline Nodes: " + numberOfflineNodes)
println ("Number of Nodes: " + numberNodes)
----

////
Pages to mark as deprecated by this document:

https://wiki.jenkins.io/display/JENKINS/Distributed+builds
////
