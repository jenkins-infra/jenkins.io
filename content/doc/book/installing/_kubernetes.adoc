==== Installing Jenkins on a Kubernetes Cluster Using Helm v3

A typical Jenkins deployment consists of a controller node and, optionally, one or more agents. To simplify the deployment of Jenkins, we‚Äôll use link:https://helm.sh/[Helm] to deploy Jenkins. 
Helm is a package manager for Kubernetes and its package format is called a chart. 
Many community-developed charts are available on link:https://github.com/helm/charts[GitHub].

Helm Charts provide ‚Äúpush button‚Äù deployment and deletion of apps, making adoption and development of Kubernetes apps easier for those with little container or microservices experience.

===== Prerequisites

. Helm CLI. If you don't have Helm CLI installed and configured locally, see the ‚ÄúInstalling Helm and Setting Up Helm‚Äù sections below.

===== Installing Helm

To install Helm CLI, follow the instructions from the link:https://helm.sh/docs/intro/install/[Installing Helm] page.

===== Setting Up Helm
Once Helm is installed and set up properly, add the Jenkinsci repo as follows:

[source,bash]
----
helm repo add jenkinsci https://charts.jenkins.io
----

[source,bash]
----
helm repo update
----

You can then run `helm search repo jenkinsci` to see the charts.

===== Create a persistent volume for the Jenkins master

We want to create a link:https://kubernetes.io/docs/concepts/storage/persistent-volumes/[persistent volume] for our Jenkins master pod. This will prevent us from losing our whole configuration of the Jenkins master and our jobs when we reboot our minikube. This link:https://github.com/kubernetes/minikube/blob/master/docs/persistent_volumes.md[official minikube doc] explains which directories we can use to mount or data. In a multi-node Kubernetes cluster, you‚Äôll need some solution like NFS to make the mount directory available in the whole cluster. But because we use minikube which is a one-node cluster we don‚Äôt have to bother about it.

We choose to use the /data directory. This directory will contain our Jenkins master configuration.

*We will create a volume which is called jenkins-pv:*

1. Paste the following snippet into a file called jenkins-volume.yaml:

[source,bash]
----
apiVersion: v1
kind: PersistentVolume
metadata:
  name: jenkins-pv
  namespace: jenkins-project
spec:
  storageClassName: jenkins-pv
  accessModes:
    - ReadWriteOnce
  capacity:
    storage: 20Gi
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /data/jenkins-volume/
----

2. Run the following command to apply the spec:

[source,bash]
----
kubectl apply -f jenkins-volume.yaml
----

[NOTE]
====

It‚Äôs worth noting that, in the above spec, hostPath uses the /data/jenkins-volume/ of your node to emulate network-attached storage. This approach is only suited for development and testing purposes. For production, you should provide a network resource like a Google Compute Engine persistent disk, or an Amazon Elastic Block Store volume.

====

===== Create a Service Account for Jenkins

In Kubernetes, service accounts are used to provide an identity for pods. Pods that want to interact with the API server will authenticate with a particular service account. By default, applications will authenticate as the `default` service account in the namespace they are running in. This means, for example, that an application running in the `test` namespace will use the default service account of the `test` namespace

*We will create a service account called jenkins:*

1. Paste the following snippet into a file called jenkins-sa.yaml:

[source,bash]
---
  apiVersion: v1
  kind: ServiceAccount
  metadata:
    name: jenkins
---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRole
  metadata:
    annotations:
      rbac.authorization.kubernetes.io/autoupdate: "true"
    labels:
      kubernetes.io/bootstrapping: rbac-defaults
    name: jenkins
  rules:
  - apiGroups:
    - '*'
    resources:
    - statefulsets
    - services
    - replicationcontrollers
    - replicasets
    - podtemplates
    - podsecuritypolicies
    - pods
    - pods/log
    - pods/exec
    - podpreset
    - poddisruptionbudget
    - persistentvolumes
    - persistentvolumeclaims
    - jobs
    - endpoints
    - deployments
    - deployments/scale
    - daemonsets 
    - cronjobs
    - configmaps
    - namespaces
    - events
    - secrets
    verbs:
    - create
    - get
    - watch
    - delete
    - list
    - patch
    - apply
    - update
    - apiGroups:
    - ""
    resources:
    - nodes
    verbs:
    - get
    - list
    - watch
    - update
---
  apiVersion: rbac.authorization.k8s.io/v1
  kind: ClusterRoleBinding
  metadata:
    annotations:
      rbac.authorization.kubernetes.io/autoupdate: "true"
    labels:
kubernetes.io/bootstrapping: rbac-defaults
    name: jenkins
  roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: jenkins
  subjects:
  - apiGroup: rbac.authorization.k8s.io
    kind: Group
    name: system:serviceaccounts:jenkins
----

A ClusterRole is a set of permissions that can be assigned to resources within a given cluster.
Kubernetes APIs are categorized into API groups, based on the API objects that they relate to.
While creating a ClusterRole, you can specify the operations that can be performed by the ClusterRole on one or more API objects in one or more API groups, just as we have done above.
lusterRoles have several uses. You can use a ClusterRole to:

. define permissions on namespaced resources and be granted within individual namespace(s)
. define permissions on namespaced resources and be granted across all namespaces
. define permissions on cluster-scoped resources

If you want to define a role within a namespace, use a Role; if you want to define a role cluster-wide, use a ClusterRole.

On the other hand, a role binding grants the permissions defined in a role to a user or set of users. It holds a list of subjects (users, groups, or service accounts), and a reference to the role being granted. A RoleBinding grants permissions within a specific namespace whereas a ClusterRoleBinding grants that access cluster-wide.

A RoleBinding may reference any Role in the same namespace. 
Alternatively, a RoleBinding can reference a ClusterRole and bind that 
ClusterRole to the namespace of the RoleBinding. 
To bind a ClusterRole to all the namespaces in our cluster, we use a ClusterRoleBinding.

2. Run the following command to apply the spec:

[source,bash]
----
kubectl apply -f jenkins-sa.yaml
----

===== Installing Jenkins

We will deploy a Jenkins controller-agent cluster utilizing the Jenkins Kubernetes plugin. Here you can find the official chart.

1. To enable persistence, we will create an override file and pass it as an argument to the Helm CLI. Paste the content from https://raw.githubusercontent.com/jenkinsci/helm-charts/main/charts/jenkins/values.yaml into a YAML formatted file called jenkins-values.yaml.

The `jenkins-values.yaml` is used as a template to provide values that are necessary for setup.

2. Open the jenkins-values.yaml file in your favorite text editor and modify the following:
* nodePort: Because we are using minikube we need to use NodePort as service type. Only cloud providers offer load balancers. We define port 32000 as port.

* storageClass: 
[source,bash]
----
storageClass:
to:
storageClass: jenkins-pv 
----

* serviceAccount: the serviceAccount section of the jenkins-values.yaml file should look like this:
[source,bash]
----
serviceAccount:
  create: false
  # The name of the service account is autogenerated by default
  name: jenkins
  annotations: {}
----

Where `name: jenkins` refers to the serviceAccount created for jenkins

* We can also define which plugins we want to install on our Jenkins. We use some default plugins like git and the pipeline plugin.

3. Now you can install Jenkins by running the `helm install` command and passing it the following arguments:

* The name of the release `jenkins`
* The -f flag with the YAML file with overrides `jenkins-values.yaml`
* The name of the chart `jenkinsci/jenkins`
* The `--namespace` flag with the name of your namespace `jenkins`

[source,bash]
----
helm install jenkins -f jenkins-values.yaml jenkinsci/jenkins --namespace jenkins
----

This outputs something similar to the following:

[source,bash]
----
NAME: jenkins
LAST DEPLOYED: Wed Sep 16 11:13:10 2020
NAMESPACE: jenkins
STATUS: deployed
REVISION: 1
NOTES:
1. Get your 'admin' user password by running:
  printf $(kubectl get secret --namespace jenkins jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode);echo
2. Get the Jenkins URL to visit by running these commands in the same shell:
  export NODE_PORT=$(kubectl get --namespace jenkins -o jsonpath="{.spec.ports[0].nodePort}" services jenkins)
  export NODE_IP=$(kubectl get nodes --namespace jenkins -o jsonpath="{.items[0].status.addresses[0].address}")
  echo http://$NODE_IP:$NODE_PORT/login
3. Login with the password from step 1 and the username: admin
4. Use Jenkins Configuration as Code by specifying configScripts in your values.yaml file, see documentation: http:///configuration-as-code and examples: https://github.com/jenkinsci/configuration-as-code-plugin/tree/master/demos
 
For more information on running Jenkins on Kubernetes, visit:
https://cloud.google.com/solutions/jenkins-on-container-engine
For more information about Jenkins Configuration as Code, visit:
https://jenkins.io/projects/jcasc/
----

4. Depending on your environment, it can take a bit of time for Jenkins to start up. Enter the following command to inspect the status of your Pod:

[source,bash]
----
kubectl get pods --namespace=jenkins
----

Once Jenkins is installed, the status should be  set to Running as in the following output:

[source,bash]
----
‚ùØ kubectl get pods --namespace=jenkins
NAME                       READY   STATUS    RESTARTS   AGE
jenkins-645fbf58d6-6xfvj   1/1     Running   0          2m
----

5. To access your Jenkins server, you must retrieve the password. You can retrieve your password using either of the two options below.

*Option 1*

Run the following command:

[source,bash]
----
printf $(kubectl get secret --namespace jenkins jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode);echo
----

The output should look like this:

[source,bash]
----
Um1kJLOWQY
----

üëÜüèªNote that your password will be different.

*Option 2*

Run the following command:

[source,bash]
----
kubectl get secret --namespace jenkins jenkins -o jsonpath="{.data.jenkins-admin-password}"
----

The output should be a base64 encoded string like this:

[source,bash]
----
WkIwRkdnbDZYZg==
----

Decode the base64 string and you have your password. You can use this website to decode your output. 

6. Get the name of the Pod running that is running Jenkins using the following command:

[source,bash]
----
Kubectl get pods --namespace jenkins
----

7. Use the kubectl command to set up port forwarding:

[source,bash]
----
‚ùØ kubectl --namespace jenkins port-forward <pod_name> 8080:8080
Forwarding from 127.0.0.1:8080 -> 8080
Forwarding from [::1]:8080 -> 8080
----

Visit http://127.0.0.1:8080/ and log in using `admin` as the username and the password you retrieved earlier.