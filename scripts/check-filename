#!/usr/bin/env bash
set -euo pipefail

dir="${1:-./content/blog/}"
if [[ -z "$dir" ]]; then
  echo "Usage: $0 <directory>"
  exit 2
fi

if [[ "$dir" != "/" ]]; then
  dir="${dir%/}"
fi

if [[ ! -d "$dir" ]]; then
  echo "ERROR: $dir is not a directory"
  exit 3
fi

# Valid basename pattern: 4 digits-2 digits-2 digits, optionally followed by '-' or '.' and the rest
# Examples: 2026-01-31, 2026-01-31-title.md, 2026-01-31.md
regex='^[0-9]{4}-[0-9]{2}-[0-9]{2}([-.].*)?$'

# Walk files portably (BSD/GNU find) then validate within bash.
non_matching=()
while IFS= read -r -d '' file; do
  base_name="${file##*/}"
  [[ "$base_name" == "index.html.haml" ]] && continue

  rel_path="$file"
  if [[ "$dir" != "." && "$rel_path" == "$dir"/* ]]; then
    rel_path="${rel_path#"$dir"/}"
  elif [[ "$dir" == "." && "$rel_path" == ./* ]]; then
    rel_path="${rel_path#./}"
  fi

  if [[ ! "$base_name" =~ $regex ]]; then
    non_matching+=("$rel_path")
  fi
done < <(find "$dir" \( -type d -name authors -prune \) -o -type f -print0)

if (( ${#non_matching[@]} )); then
  echo "ERROR: non-matching files:"
  printf '%s\n' "${non_matching[@]}"
  exit 1
fi

echo "OK: all file names match"
exit 0
