def recordDeployment(owner, repo, status, environmentURL, environment = "preview", description = "Deploy to preview environment") {
  withCredentials([usernamePassword(credentialsId: 'github-app-infra', usernameVariable: 'GITHUB_APP', passwordVariable: 'GH_TOKEN')]) {
    withEnv([
        "OWNER=${owner}",
        "REPO=${repo}",
        "STATUS=${status}",
        "ENVIRONMENT_URL=${environmentURL}",
        "ENVIRONMENT=${environment}",
        "DESCIPTION=${description}",
    ]) {
      def id = readJSON(text: sh(script: 'gh api repos/${OWNER}/${REPO}/deployments -f "ref=${GIT_COMMIT}" -f "environment=${ENVIRONMENT}" -f "description=${DESCIPTION}" -X POST', returnStdout: true).trim()).id
      if (id == ''){
        error('Unable to create deployment')
      }
      withEnv([ "DEPLOYMENT_ID=${id}" ]) {
        sh('gh api repos/${OWNER}/${REPO}/deployments/${DEPLOYMENT_ID}/statuses -f "state=${STATUS}"  -f "environment=${ENVIRONMENT}" -f "description=${DESCIPTION}" -f "log_url=${BUILD_URL}/console" -f "environment_url=${ENVIRONMENT_URL}"')
      }
    }
  }
}

pipeline {
  agent {
    kubernetes {
      inheritFrom 'jnlp-linux'
      yaml '''
apiVersion: "v1"
kind: "Pod"
metadata:
  labels:
    jenkins: "agent"
    job: "jenkins-io"
spec:
  tolerations:
    - key: "os"
      operator: "Equal"
      value: "linux"
      effect: "NoSchedule"
  affinity:
    nodeAffinity:
      requiredDuringSchedulingIgnoredDuringExecution:
        nodeSelectorTerms:
          - matchExpressions:
              - key: kubernetes.io/os
                operator: In
                values:
                  - linux
  restartPolicy: "Never"
  containers:
    - name: "node"
      image: "node:16.13.1"
      securityContext:
        privileged: false
      tty: true
      command:
      - cat
    - name: "ruby"
      image: "ruby:2.6.9"
      securityContext:
        privileged: false
      tty: true
      command:
      - cat
    - name: "blobxfer"
      image: "mcr.microsoft.com/blobxfer:1.9.1"
      command:
      - cat
      securityContext:
        privileged: false
      tty: true
    - name: "builder"
      image: "jenkinsciinfra/builder:1.2.0"
      command:
      - cat
      securityContext:
        privileged: false
      tty: true
      '''
    }
  }

  environment {
    TZ = "UTC"
    USE_LOCAL_NODE = "true"
    USE_LOCAL_RUBY = "true"
    HOME = "/tmp"
  }

  triggers {
    cron("${env.BRANCH_NAME == 'master' ? 'H/30 * * * *' : ''}")
  }

  options {
    timeout(time: 60, unit: 'MINUTES')
    ansiColor('xterm')
    disableConcurrentBuilds()
    buildDiscarder logRotator(artifactDaysToKeepStr: '', artifactNumToKeepStr: '', daysToKeepStr: '5', numToKeepStr: '5')
  }

  stages {
    stage('NPM Install') {
      steps {
        container('node') {
          sh 'npm install'
        }
      }
    }

    stage('Bundle Install') {
      steps {
        container('ruby') {
          // throw errors if Gemfile has been modified since Gemfile.lock
          sh 'bundle config --global frozen 1'
          sh 'bundle install'
        }
      }
    }

    stage('Build') {
      steps {
        container('node') {
          sh 'make assets'
        }
        container('ruby') {
          sh 'make fetch'
        }
        container('ruby') {
          sh 'make real_generate'
        }
      }
    }

    /*
    stage('Deploy to azure') {
      when {
        branch "master"
      }
      environment {
        BLOBXFER_STORAGEACCOUNTKEY = credentials('BLOBXFER_STORAGEACCOUNTKEY')
      }
      steps {
        container('blobxfer') {
          sh('''
              blobxfer upload \
            --local-path build/_site \
            --storage-account-key $BLOBXFER_STORAGEACCOUNTKEY \
            --storage-account prodjenkinsio \
            --remote-path jenkinsio \
            --recursive \
            --mode file \
            --skip-on-md5-match \
            --file-md5 \
            --connect-timeout 30
          ''')
        }
      }
    }
    */

    stage('Deploy master to netlify') {
      when {
        branch "master"
      }
      environment {
        NETLIFY_AUTH_TOKEN = credentials('netlify-auth-token')
      }
      steps {
        container('node') {
          script {
            def netlifySite = readJSON(text: sh(script: 'npx netlify sites:list --json', returnStdout: true).trim()).find { it.name == "jenkins-io-site-pr" }
            env.NETLIFY_SITE_ID = netlifySite['site_id']
            env.NETLIFY_DOMAIN = netlifySite['default_domain']
          }
          sh('npx netlify deploy --message "Deploy" -d build/_site')
        }
      }
    }
    stage('Deploy to preview site') {
      when {
        changeRequest target: 'master'
      }
      environment {
        NETLIFY_AUTH_TOKEN = credentials('netlify-auth-token')
      }
      post {
        success {
          container('builder') {
            recordDeployment('jenkins-infra', 'plugin-site', 'success', "https://deploy-preview-${CHANGE_ID}--jenkins-plugin-site-pr.netlify.app")
          }
        }
        failure {
          container('builder') {
            recordDeployment('jenkins-infra', 'plugin-site', 'failure', "https://deploy-preview-${CHANGE_ID}--jenkins-plugin-site-pr.netlify.app")
          }
        }
      }
      steps {
        container('node') {
          script {
            def netlifySite = readJSON(text: sh(script: 'npx netlify sites:list --json', returnStdout: true).trim()).find { it.name == "jenkins-io-site-pr" }
            env.NETLIFY_SITE_ID = netlifySite['site_id']
            env.NETLIFY_DOMAIN = netlifySite['default_domain']
          }
          sh('npx netlify deploy --message "Preview deploy for ${CHANGE_ID}" --alias "deploy-preview-${CHANGE_ID}" -d build/_site')
        }
      }
    }
  }
}
